# 定义请求限制区域
limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
limit_req_zone $binary_remote_addr zone=user_limit:10m rate=5r/s;
limit_req_zone $binary_remote_addr zone=python_limit:10m rate=5r/s;

# 添加map指令用于解析请求URI，提取文章ID、分类ID等
map $request_uri $article_id {
    ~^/article/([0-9]+)$ $1;
    default "";
}

map $request_uri $category_id {
    ~^/category/([0-9]+)$ $1;
    default "";
}

map $request_uri $tag_id {
    ~^/tag/([0-9]+)$ $1;
    default "";
}

server {
    listen 80;
    server_name example.com www.example.com;
    
    # 设置访问日志路径
    access_log /var/log/nginx/access.log main;
    
    # 设置默认字符集
    charset utf-8;
    # HTTP/3
    add_header Alt-Svc 'h3=":443"; ma=86400';
    
    # 添加更多安全头信息
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' *.jsdelivr.net cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' *.jsdelivr.net fonts.googleapis.com; img-src 'self' data: blob: *; font-src 'self' data: *.jsdelivr.net fonts.googleapis.com fonts.gstatic.com; connect-src 'self' *;" always;
    
    # 防止点击劫持
    add_header X-Frame-Options "SAMEORIGIN";
    
    # 限制请求大小，防止DoS攻击
    client_max_body_size 10M;
    
    # 启用Brotli压缩 - 比GZIP更高效的压缩算法
    brotli on;
    brotli_comp_level 6;
    brotli_static on;
    brotli_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript application/x-font-ttf application/x-font-opentype application/font-woff application/font-woff2 font/woff2 image/svg+xml;
    
    # 启用GZIP压缩
    gzip on;
    gzip_disable "msie6";
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript application/x-font-ttf application/x-font-opentype application/font-woff application/font-woff2 font/woff2 image/svg+xml;
    
    # 内部代理location - 仅供内部请求使用
    location /internal_proxy/ {
        internal;
        # 移除/internal_proxy前缀
        rewrite ^/internal_proxy(/.*)$ $1 break;
        proxy_pass http://poetize-python:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # 主站前端
    location / {
        root /usr/share/nginx/html/poetize;
        index index.html;
        
        # 开启SSI处理
        ssi on;
        ssi_silent_errors on;
        
        # 启用sub_filter进行替换 - 更直接的替换方式
        sub_filter_once on;
        sub_filter_types text/html;
        
        # 在访问阶段统一处理SEO信息
        access_by_lua_block {
            local cjson = require "cjson"
            local http = require "resty.http"
            
            -- 使用ngx.ctx来存储数据，避免ngx.var的限制
            ngx.ctx.seo_data = ""
            ngx.ctx.title = ""
            ngx.ctx.has_title = false
            -- 添加注入标志，防止重复插入
            ngx.ctx.seo_injected = false
            ngx.ctx.title_injected = false
            
            -- 使用HTTP客户端的API调用函数，支持HTTP/2
            local function fetch_api(api_path, query_params)
                -- 尝试从缓存读取数据
                local seo_cache = ngx.shared.seo_cache
                local cache_key = api_path
                
                -- 如果有查询参数，将其添加到缓存键中
                if query_params then
                    for k, v in pairs(query_params) do
                        if type(v) == "string" and v ~= "" then
                            cache_key = cache_key .. ":" .. k .. "=" .. v
                        end
                    end
                end
                
                -- 检查缓存中是否有数据
                local cached_data = seo_cache:get(cache_key)
                if cached_data then
                    -- ngx.log(ngx.INFO, "从缓存读取SEO数据: " .. cache_key)
                    return cached_data
                end
                
                -- ngx.log(ngx.INFO, "发起HTTP请求: " .. api_path)
                
                -- 创建HTTP客户端
                local httpc = http.new()
                httpc:set_timeout(5000) -- 5秒超时
                
                -- 构建请求URL
                local backend_url = "http://poetize-python:5000" .. api_path
                
                -- 构建查询参数
                local query_string = ""
                if query_params then
                    local params = {}
                    for k, v in pairs(query_params) do
                        if type(v) == "string" and v ~= "" then
                            table.insert(params, k .. "=" .. ngx.escape_uri(v))
                        end
                    end
                    if #params > 0 then
                        query_string = "?" .. table.concat(params, "&")
                    end
                end
                
                -- 发起HTTP请求
                local res, err = httpc:request_uri(backend_url .. query_string, {
                    method = "GET",
                    headers = {
                        ["Host"] = ngx.var.host,
                        ["X-Real-IP"] = ngx.var.remote_addr,
                        ["X-Forwarded-For"] = ngx.var.proxy_add_x_forwarded_for or ngx.var.remote_addr,
                        ["X-Forwarded-Proto"] = ngx.var.scheme,
                        ["User-Agent"] = "nginx-lua-seo-client"
                    }
                })
                
                if not res then
                    ngx.log(ngx.ERR, "HTTP请求失败: " .. (err or "未知错误"))
                    return nil
                end
                
                -- ngx.log(ngx.INFO, "HTTP响应状态码: " .. res.status)
                if res.body then
                    -- ngx.log(ngx.INFO, "HTTP响应前100个字符: " .. string.sub(res.body, 1, 100))
                end
                
                if res.status ~= 200 then
                    ngx.log(ngx.ERR, "HTTP请求状态码异常: " .. res.status)
                    return nil
                end
                
                if not res.body or res.body == "" then
                    ngx.log(ngx.ERR, "HTTP返回内容为空")
                    return nil
                end
                
                -- 尝试解析JSON
                local ok, data = pcall(cjson.decode, res.body)
                if not ok then
                    ngx.log(ngx.ERR, "HTTP返回内容不是有效的JSON: " .. res.body)
                    -- 尝试直接使用返回的内容作为字符串
                    if type(res.body) == "string" then
                        return res.body
                    end
                    return nil
                end
                
                -- 记录解析后的JSON数据结构
                -- ngx.log(ngx.INFO, "解析后的JSON数据类型: " .. type(data))
                if type(data) == "table" then
                    if data.status then
                        -- ngx.log(ngx.INFO, "JSON status字段: " .. data.status)
                    end
                    if data.data then
                        -- ngx.log(ngx.INFO, "JSON data字段类型: " .. type(data.data))
                        if type(data.data) == "string" then
                            -- ngx.log(ngx.INFO, "JSON data字段前50个字符: " .. string.sub(data.data, 1, 50))
                        end
                    else
                        ngx.log(ngx.WARN, "JSON中无data字段")
                    end
                end
                
                -- 处理JSON格式的返回数据
                if not data then
                    ngx.log(ngx.ERR, "解析的JSON数据为空")
                    return nil
                end
                
                -- 检查JSON数据中的状态
                if data.status and data.status ~= "success" then
                    ngx.log(ngx.ERR, "HTTP返回状态不成功: " .. data.status .. (data.message or ""))
                    return nil
                end
                
                -- 检查data字段
                if not data.data then
                    ngx.log(ngx.ERR, "HTTP返回中缺少data字段")
                    -- 尝试直接返回JSON对象
                    return cjson.encode(data)
                end
                
                -- 根据data的类型返回适当的值，并处理title标签
                local result
                if type(data.data) == "string" then
                    -- 提取title标签中的内容
                    local title_start = string.find(data.data, "<title>")
                    local title_end = string.find(data.data, "</title>")
                    
                    if title_start and title_end and title_end > title_start then
                        -- 设置title变量，但从返回数据中移除title标签
                        ngx.ctx.title = string.sub(data.data, title_start + 7, title_end - 1)
                        -- ngx.log(ngx.INFO, "已提取title并从SEO数据中移除: " .. ngx.ctx.title)
                        
                        -- 移除title标签
                        local before_title = string.sub(data.data, 1, title_start - 1) or ""
                        local after_title = string.sub(data.data, title_end + 8) or ""
                        result = before_title .. after_title
                    else
                        result = data.data
                    end
                elseif type(data.data) == "table" then
                    -- 将JSON表转为字符串
                    result = cjson.encode(data.data)
                else
                    -- 转换为字符串
                    result = tostring(data.data)
                end
                
                -- 缓存结果 (保存12小时)
                if result and type(result) == "string" then
                    local success, err = seo_cache:set(cache_key, result, 43200)
                    if not success then
                        ngx.log(ngx.ERR, "缓存SEO数据失败: " .. (err or "未知错误"))
                    else
                        -- ngx.log(ngx.INFO, "成功缓存SEO数据: " .. cache_key)
                    end
                end
                
                return result
            end
            
            -- 获取文章SEO数据
            local article_id = ngx.var.article_id
            if article_id and article_id ~= "" then
                -- ngx.log(ngx.INFO, "检测到文章ID: ", article_id)
                local data = fetch_api("/python/seo/getArticleMeta", {
                    id = article_id
                })
                
                if data then
                    ngx.ctx.seo_data = data
                    -- ngx.log(ngx.INFO, "成功获取文章SEO数据")
                else
                    ngx.log(ngx.WARN, "获取文章SEO数据失败")
                end
            end
            
            -- 如果没有文章数据，尝试获取分类SEO数据
            if not ngx.ctx.seo_data or ngx.ctx.seo_data == "" then
                local category_id = ngx.var.category_id
                if category_id and category_id ~= "" then
                    -- ngx.log(ngx.INFO, "检测到分类ID: ", category_id)
                    local data = fetch_api("/python/seo/getCategoryMeta", {
                        id = category_id
                    })
                    
                    if data then
                        ngx.ctx.seo_data = data
                        -- ngx.log(ngx.INFO, "成功获取分类SEO数据")
                    else
                        ngx.log(ngx.WARN, "获取分类SEO数据失败")
                    end
                end
            end
            
            -- 如果仍然没有数据，获取站点默认SEO数据
            if not ngx.ctx.seo_data or ngx.ctx.seo_data == "" then
                -- ngx.log(ngx.INFO, "尝试获取站点默认SEO数据")
                local data = fetch_api("/python/seo/getSiteMeta", {
                })
                
                if data then
                    ngx.ctx.seo_data = data
                    -- ngx.log(ngx.INFO, "成功获取站点SEO数据")
                else
                    ngx.log(ngx.WARN, "获取站点SEO数据失败")
                    -- 使用默认的SEO元数据，而非空字符串
                    ngx.ctx.seo_data = '<meta name="description" content="Poetize - 一个优雅的博客平台">'
                        .. '<meta name="keywords" content="poetize,blog,poetry,文章,博客">'
                        .. '<meta property="og:title" content="Poetize">'
                        .. '<meta property="og:description" content="一个优雅的博客平台">'
                        .. '<meta property="og:type" content="website">'
                    -- ngx.log(ngx.INFO, "使用默认硬编码的SEO数据")
                end
            end
            
            -- 确保seo_data是字符串类型
            if ngx.ctx.seo_data and type(ngx.ctx.seo_data) ~= "string" then
                ngx.log(ngx.WARN, "SEO数据不是字符串，尝试转换")
                local ok, str_data = pcall(function() return tostring(ngx.ctx.seo_data) end)
                if ok and str_data then
                    ngx.ctx.seo_data = str_data
                else
                    ngx.log(ngx.ERR, "SEO数据转换为字符串失败")
                    ngx.ctx.seo_data = ""
                end
            end
            
            -- 提取标题 - 假设seo_data是HTML格式
            if ngx.ctx.seo_data and type(ngx.ctx.seo_data) == "string" and ngx.ctx.seo_data ~= "" then
                -- 安全地查找title
                local title_start = string.find(ngx.ctx.seo_data, "<title>")
                local title_end = string.find(ngx.ctx.seo_data, "</title>")
                
                if title_start and title_end and title_end > title_start then
                    ngx.ctx.title = string.sub(ngx.ctx.seo_data, title_start + 7, title_end - 1)
                    -- ngx.log(ngx.INFO, "提取到标题: ", ngx.ctx.title)
                    
                    -- 移除title标签
                    local before_title = string.sub(ngx.ctx.seo_data, 1, title_start - 1) or ""
                    local after_title = string.sub(ngx.ctx.seo_data, title_end + 8) or ""
                    ngx.ctx.seo_data = before_title .. after_title
                else
                    ngx.log(ngx.WARN, "SEO数据中未找到标题标签")
                end
            end
            
            -- 确保有默认值
            if not ngx.ctx.title or ngx.ctx.title == "" then
                ngx.ctx.title = "Poetize"
                -- ngx.log(ngx.INFO, "使用默认标题: Poetize")
            end
            
            -- 初始化title_injected为false
            ngx.ctx.title_injected = false
            -- ngx.log(ngx.INFO, "初始化标题注入状态为false")
            
            -- 储存SEO占位符和替换目标
            ngx.ctx.meta_placeholder = "<!-- SEO_META_PLACEHOLDER -->"
        }
        
        # 用于在模板中插入完整的头部信息
        header_filter_by_lua_block {
            -- 设置头部，允许后续修改
            ngx.header.content_length = nil
            
            -- 确保只处理HTML内容
            local content_type = ngx.header.content_type
            if not content_type or not string.find(content_type, "text/html", 1, true) then
                return
            end
        }
        
        body_filter_by_lua_block {
            local chunk = ngx.arg[1]
            if not chunk then return end
            
            -- 确保只处理HTML内容
            local content_type = ngx.header.content_type
            if not content_type or not string.find(content_type, "text/html", 1, true) then
                return
            end
            
            -- 改进的SEO数据检查函数
            local function has_seo_meta(html)
                -- 检查是否已有关键的SEO meta标签
                local patterns = {
                    '<meta[^>]*name=["\']description["\'][^>]*>',
                    '<meta[^>]*name=["\']keywords["\'][^>]*>',
                    '<meta[^>]*property=["\']og:title["\'][^>]*>',
                    '<meta[^>]*property=["\']og:description["\'][^>]*>'
                }
                
                local found_count = 0
                for _, pattern in ipairs(patterns) do
                    if string.find(html, pattern) then
                        found_count = found_count + 1
                    end
                end
                
                -- 如果找到2个或以上的关键meta标签，认为已有SEO数据
                return found_count >= 2
            end
            
            -- 注入SEO数据
            if ngx.ctx.seo_data and type(ngx.ctx.seo_data) == "string" and ngx.ctx.seo_data ~= "" and not ngx.ctx.seo_injected then
                -- 检查是否已存在SEO数据
                if has_seo_meta(chunk) then
                    -- ngx.log(ngx.INFO, "检测到页面已有SEO数据，跳过插入")
                    ngx.ctx.seo_injected = true
                else
                    -- 查找占位符并替换
                    local placeholder_exist = string.find(chunk, "<!-- SEO_META_PLACEHOLDER -->", 1, true)
                    if placeholder_exist then
                        -- 替换占位符
                        local clean_seo = string.gsub(ngx.ctx.seo_data, "\\\"", "\"")
                        chunk = string.gsub(chunk, "<!-- SEO_META_PLACEHOLDER -->", clean_seo)
                        -- ngx.log(ngx.INFO, "占位符替换成功")
                        ngx.ctx.seo_injected = true
                    else
                        -- 在head标签后插入
                        local head_tag = string.find(chunk, "<head>", 1, true)
                        if head_tag then
                            local clean_seo = string.gsub(ngx.ctx.seo_data, "\\\"", "\"")
                            chunk = string.gsub(chunk, "<head>", "<head>" .. clean_seo, 1)
                            -- ngx.log(ngx.INFO, "在head标签后插入SEO数据")
                            ngx.ctx.seo_injected = true
                        end
                    end
                end
            end
            
            -- 注入title标签
            if ngx.ctx.title and ngx.ctx.title ~= "" and not ngx.ctx.title_injected then
                -- 查找现有title标签及其内容
                local title_pattern = "<title[^>]*>(.-)</title>"
                local existing_title_content = nil
                
                for content in string.gmatch(chunk, title_pattern) do
                    existing_title_content = content
                    break
                end
                
                if existing_title_content then
                    -- ngx.log(ngx.INFO, "现有title内容: " .. existing_title_content)
                    
                    -- 检查是否需要修复重复或替换标题
                    if existing_title_content ~= ngx.ctx.title then
                        -- 检查是否包含重复模式
                        local repeated_pattern = ngx.ctx.title .. ngx.ctx.title
                        if existing_title_content == repeated_pattern or string.find(existing_title_content, repeated_pattern, 1, true) then
                            -- 修复重复的标题
                            chunk = string.gsub(chunk, "<title[^>]*>" .. existing_title_content .. "</title>", "<title>" .. ngx.ctx.title .. "</title>", 1)
                            -- ngx.log(ngx.INFO, "修复重复的title内容")
                        else
                            -- 替换不同的标题
                            chunk = string.gsub(chunk, "<title[^>]*>" .. existing_title_content .. "</title>", "<title>" .. ngx.ctx.title .. "</title>", 1)
                            -- ngx.log(ngx.INFO, "替换不同的title内容")
                        end
                        ngx.ctx.title_injected = true
                    else
                        -- ngx.log(ngx.INFO, "现有title已是目标title，无需修改")
                        ngx.ctx.title_injected = true
                    end
                else
                    -- 没有找到title标签，添加一个
                    local title_count = select(2, string.gsub(chunk, "<title", ""))
                    
                    if title_count > 1 then
                        -- 移除所有title标签并添加一个新的
                        chunk = string.gsub(chunk, "<title[^>]*>.-</title>", "")
                        chunk = string.gsub(chunk, "<head>", "<head><title>" .. ngx.ctx.title .. "</title>", 1)
                        -- ngx.log(ngx.INFO, "移除重复title标签并添加新标签")
                    elseif title_count == 1 then
                        -- 替换空的title标签
                        chunk = string.gsub(chunk, "<title[^>]*>.-</title>", "<title>" .. ngx.ctx.title .. "</title>", 1)
                        -- ngx.log(ngx.INFO, "替换空的title标签")
                    else
                        -- 添加新的title标签
                        local head_exists = string.find(chunk, "<head>", 1, true)
                        if head_exists then
                            chunk = string.gsub(chunk, "<head>", "<head><title>" .. ngx.ctx.title .. "</title>", 1)
                            -- ngx.log(ngx.INFO, "添加新的title标签")
                        end
                    end
                    ngx.ctx.title_injected = true
                end
            end
            
            -- 去重meta标签
            local seen_meta = {}
            chunk = ngx.re.gsub(chunk, [[<meta[^>]*(name|property)="([^"]+)"[^>]*content="([^"]*)"[^>]*>]], function(m)
                local key = m[1] .. ":" .. m[2]
                if seen_meta[key] then 
                    -- ngx.log(ngx.INFO, "移除重复的meta标签: " .. key)
                    return "" 
                end
                seen_meta[key] = true
                return m[0]
            end, "jo")
            
            ngx.arg[1] = chunk
        }
        
        # 最后尝试匹配文件路径
        try_files $uri $uri/ /index.html;
        
        # Live2D资源预加载 - 使用JavaScript preload代替http2_push
        # 注：HTTP/3不支持Server Push，改用<link rel="preload">方式
        location = /index.html {
            root /usr/share/nginx/html/poetize;
            add_header Link '</static/live2d-widget/dist/live2d.min.js>; rel=preload; as=script';
            add_header Link '</static/live2d-widget/dist/waifu.css>; rel=preload; as=style';
            add_header Link '</static/live2d_api/model_list.json>; rel=preload; as=fetch; crossorigin=anonymous';
        }
    }
    
    # Let's Encrypt验证 - 保留此部分以便certbot可以验证域名
    location /.well-known/acme-challenge/ {
        root /usr/share/nginx/html;
        allow all;
    }
    
    # 聊天室前端
    location /im {
        alias /usr/share/nginx/html/im;
        index index.html;
        
        # 开启SSI处理
        ssi on;
        ssi_silent_errors on;
        
        # 启用sub_filter进行替换 - 更直接的替换方式
        sub_filter_once on;
        sub_filter_types text/html;
        
        # 在访问阶段处理IM聊天室SEO信息
        access_by_lua_block {
            local cjson = require "cjson"
            local http = require "resty.http"
            
            -- 使用ngx.ctx来存储数据
            ngx.ctx.seo_data = ""
            ngx.ctx.title = ""
            
            -- 使用HTTP客户端的API调用函数，支持HTTP/2
            local function fetch_api(api_path, query_params)
                -- ngx.log(ngx.INFO, "IM-发起HTTP请求: " .. api_path)
                
                -- 创建HTTP客户端
                local httpc = http.new()
                httpc:set_timeout(5000) -- 5秒超时
                
                -- 构建请求URL
                local backend_url = "http://poetize-python:5000" .. api_path
                
                -- 构建查询参数
                local query_string = ""
                if query_params then
                    local params = {}
                    for k, v in pairs(query_params) do
                        if type(v) == "string" and v ~= "" then
                            table.insert(params, k .. "=" .. ngx.escape_uri(v))
                        end
                    end
                    if #params > 0 then
                        query_string = "?" .. table.concat(params, "&")
                    end
                end
                
                -- 发起HTTP请求
                local res, err = httpc:request_uri(backend_url .. query_string, {
                    method = "GET",
                    headers = {
                        ["Host"] = ngx.var.host,
                        ["X-Real-IP"] = ngx.var.remote_addr,
                        ["X-Forwarded-For"] = ngx.var.proxy_add_x_forwarded_for or ngx.var.remote_addr,
                        ["X-Forwarded-Proto"] = ngx.var.scheme,
                        ["User-Agent"] = "nginx-lua-seo-client"
                    }
                })
                
                if not res then
                    ngx.log(ngx.ERR, "IM-HTTP请求失败: " .. (err or "未知错误"))
                    return nil
                end
                
                -- ngx.log(ngx.INFO, "IM-HTTP响应状态码: " .. res.status)
                if res.body then
                    -- ngx.log(ngx.INFO, "IM-HTTP响应前100个字符: " .. string.sub(res.body, 1, 100))
                end
                
                if res.status ~= 200 then
                    ngx.log(ngx.ERR, "IM-HTTP请求状态码异常: " .. res.status)
                    return nil
                end
                
                if not res.body or res.body == "" then
                    ngx.log(ngx.ERR, "IM-HTTP返回内容为空")
                    return nil
                end
                
                -- 尝试解析JSON
                local ok, data = pcall(cjson.decode, res.body)
                if not ok then
                    ngx.log(ngx.ERR, "IM-HTTP返回内容不是有效的JSON: " .. res.body)
                    -- 尝试直接使用返回的内容作为字符串
                    if type(res.body) == "string" then
                        return res.body
                    end
                    return nil
                end
                
                -- 记录解析后的JSON数据结构
                -- ngx.log(ngx.INFO, "解析后的JSON数据类型: " .. type(data))
                if type(data) == "table" then
                    if data.status then
                        -- ngx.log(ngx.INFO, "JSON status字段: " .. data.status)
                    end
                    if data.data then
                        -- ngx.log(ngx.INFO, "JSON data字段类型: " .. type(data.data))
                        if type(data.data) == "string" then
                            -- ngx.log(ngx.INFO, "JSON data字段前50个字符: " .. string.sub(data.data, 1, 50))
                        end
                    else
                        ngx.log(ngx.WARN, "JSON中无data字段")
                    end
                end
                
                -- 处理JSON格式的返回数据
                if not data then
                    ngx.log(ngx.ERR, "解析的JSON数据为空")
                    return nil
                end
                
                -- 检查JSON数据中的状态
                if data.status and data.status ~= "success" then
                    ngx.log(ngx.ERR, "IM-HTTP返回状态不成功: " .. data.status .. (data.message or ""))
                    return nil
                end
                
                -- 检查data字段
                if not data.data then
                    ngx.log(ngx.ERR, "IM-HTTP返回中缺少data字段")
                    -- 尝试直接返回JSON对象
                    return cjson.encode(data)
                end
                
                -- 根据data的类型返回适当的值
                if type(data.data) == "string" then
                    -- 提取title标签中的内容
                    local title_start = string.find(data.data, "<title>")
                    local title_end = string.find(data.data, "</title>")
                    
                    if title_start and title_end and title_end > title_start then
                        -- 设置title变量，但从返回数据中移除title标签
                        ngx.ctx.title = string.sub(data.data, title_start + 7, title_end - 1)
                        -- ngx.log(ngx.INFO, "IM-已提取title并从SEO数据中移除: " .. ngx.ctx.title)
                        
                        -- 移除title标签
                        local before_title = string.sub(data.data, 1, title_start - 1) or ""
                        local after_title = string.sub(data.data, title_end + 8) or ""
                        return before_title .. after_title
                    end
                    
                    return data.data
                elseif type(data.data) == "table" then
                    -- 将JSON表转为字符串
                    return cjson.encode(data.data)
                else
                    -- 转换为字符串
                    return tostring(data.data)
                end
            end
            
            -- 为IM页面获取特定的SEO数据
            -- ngx.log(ngx.INFO, "尝试获取IM页面特定SEO数据")
            local data = fetch_api("/python/seo/getIMSiteMeta", {})
            
            -- 如果IM特定API不可用，回退到通用站点数据
            if not data then
                ngx.log(ngx.WARN, "IM特定SEO数据获取失败，尝试使用通用站点数据")
                data = fetch_api("/python/seo/getSiteMeta", {})
            else
                -- ngx.log(ngx.INFO, "成功获取IM特定SEO数据")
            end
            
            if data then
                ngx.ctx.seo_data = data
                -- ngx.log(ngx.INFO, "成功获取SEO数据")
                
                -- 确保seo_data是字符串类型
                if ngx.ctx.seo_data and type(ngx.ctx.seo_data) ~= "string" then
                    ngx.log(ngx.WARN, "IM-SEO数据不是字符串，尝试转换")
                    local ok, str_data = pcall(function() return tostring(ngx.ctx.seo_data) end)
                    if ok and str_data then
                        ngx.ctx.seo_data = str_data
                    else
                        ngx.log(ngx.ERR, "IM-SEO数据转换为字符串失败")
                        ngx.ctx.seo_data = ""
                    end
                end
                
                -- 提取标题 - 假设seo_data是HTML格式
                if type(ngx.ctx.seo_data) == "string" and ngx.ctx.seo_data ~= "" then
                    local title_start = string.find(ngx.ctx.seo_data, "<title>")
                    local title_end = string.find(ngx.ctx.seo_data, "</title>")
                    
                    if title_start and title_end and title_end > title_start then
                        ngx.ctx.title = string.sub(ngx.ctx.seo_data, title_start + 7, title_end - 1)
                        -- ngx.log(ngx.INFO, "IM-提取到标题: ", ngx.ctx.title)
                        
                        -- 移除title标签
                        local before_title = string.sub(ngx.ctx.seo_data, 1, title_start - 1) or ""
                        local after_title = string.sub(ngx.ctx.seo_data, title_end + 8) or ""
                        ngx.ctx.seo_data = before_title .. after_title
                    else
                        ngx.log(ngx.WARN, "IM-SEO数据中未找到标题标签")
                    end
                end
            else
                ngx.log(ngx.WARN, "未能获取任何SEO数据")
                ngx.ctx.seo_data = ""
            end
            
            -- 确保有默认值 - IM专用标题
            if not ngx.ctx.title or ngx.ctx.title == "" then
                ngx.ctx.title = "Poetize IM聊天室"
                -- ngx.log(ngx.INFO, "使用默认IM标题: Poetize IM聊天室")
            end
            
            -- 储存SEO占位符和替换目标
            ngx.ctx.meta_placeholder = "<!-- SEO_META_PLACEHOLDER -->"
        }
        
        # 用于在模板中插入完整的头部信息
        header_filter_by_lua_block {
            -- 设置头部，允许后续修改
            ngx.header.content_length = nil
            
            -- 确保只处理HTML内容
            local content_type = ngx.header.content_type
            if not content_type or not string.find(content_type, "text/html", 1, true) then
                return
            end
        }
        
        body_filter_by_lua_block {
            local chunk = ngx.arg[1]
            if not chunk then return end
            
            -- 确保只处理HTML内容
            local content_type = ngx.header.content_type
            if not content_type or not string.find(content_type, "text/html", 1, true) then
                return
            end
            
            -- 改进的SEO数据检查函数
            local function has_seo_meta(html)
                -- 检查是否已有关键的SEO meta标签
                local patterns = {
                    '<meta[^>]*name=["\']description["\'][^>]*>',
                    '<meta[^>]*name=["\']keywords["\'][^>]*>',
                    '<meta[^>]*property=["\']og:title["\'][^>]*>',
                    '<meta[^>]*property=["\']og:description["\'][^>]*>'
                }
                
                local found_count = 0
                for _, pattern in ipairs(patterns) do
                    if string.find(html, pattern) then
                        found_count = found_count + 1
                    end
                end
                
                -- 如果找到2个或以上的关键meta标签，认为已有SEO数据
                return found_count >= 2
            end
            
            -- 注入SEO数据
            if ngx.ctx.seo_data and type(ngx.ctx.seo_data) == "string" and ngx.ctx.seo_data ~= "" and not ngx.ctx.seo_injected then
                -- 检查是否已存在SEO数据
                if has_seo_meta(chunk) then
                    -- ngx.log(ngx.INFO, "检测到页面已有SEO数据，跳过插入")
                    ngx.ctx.seo_injected = true
                else
                    -- 查找占位符并替换
                    local placeholder_exist = string.find(chunk, "<!-- SEO_META_PLACEHOLDER -->", 1, true)
                    if placeholder_exist then
                        -- 替换占位符
                        local clean_seo = string.gsub(ngx.ctx.seo_data, "\\\"", "\"")
                        chunk = string.gsub(chunk, "<!-- SEO_META_PLACEHOLDER -->", clean_seo)
                        -- ngx.log(ngx.INFO, "占位符替换成功")
                        ngx.ctx.seo_injected = true
                    else
                        -- 在head标签后插入
                        local head_tag = string.find(chunk, "<head>", 1, true)
                        if head_tag then
                            local clean_seo = string.gsub(ngx.ctx.seo_data, "\\\"", "\"")
                            chunk = string.gsub(chunk, "<head>", "<head>" .. clean_seo, 1)
                            -- ngx.log(ngx.INFO, "在head标签后插入SEO数据")
                            ngx.ctx.seo_injected = true
                        end
                    end
                end
            end
            
            -- 注入title标签
            if ngx.ctx.title and ngx.ctx.title ~= "" and not ngx.ctx.title_injected then
                -- 查找现有title标签及其内容
                local title_pattern = "<title[^>]*>(.-)</title>"
                local existing_title_content = nil
                
                for content in string.gmatch(chunk, title_pattern) do
                    existing_title_content = content
                    break
                end
                
                if existing_title_content then
                    -- ngx.log(ngx.INFO, "现有title内容: " .. existing_title_content)
                    
                    -- 检查是否需要修复重复或替换标题
                    if existing_title_content ~= ngx.ctx.title then
                        -- 检查是否包含重复模式
                        local repeated_pattern = ngx.ctx.title .. ngx.ctx.title
                        if existing_title_content == repeated_pattern or string.find(existing_title_content, repeated_pattern, 1, true) then
                            -- 修复重复的标题
                            chunk = string.gsub(chunk, "<title[^>]*>" .. existing_title_content .. "</title>", "<title>" .. ngx.ctx.title .. "</title>", 1)
                            -- ngx.log(ngx.INFO, "修复重复的title内容")
                        else
                            -- 替换不同的标题
                            chunk = string.gsub(chunk, "<title[^>]*>" .. existing_title_content .. "</title>", "<title>" .. ngx.ctx.title .. "</title>", 1)
                            -- ngx.log(ngx.INFO, "替换不同的title内容")
                        end
                        ngx.ctx.title_injected = true
                    else
                        -- ngx.log(ngx.INFO, "现有title已是目标title，无需修改")
                        ngx.ctx.title_injected = true
                    end
                else
                    -- 没有找到title标签，添加一个
                    local title_count = select(2, string.gsub(chunk, "<title", ""))
                    
                    if title_count > 1 then
                        -- 移除所有title标签并添加一个新的
                        chunk = string.gsub(chunk, "<title[^>]*>.-</title>", "")
                        chunk = string.gsub(chunk, "<head>", "<head><title>" .. ngx.ctx.title .. "</title>", 1)
                        -- ngx.log(ngx.INFO, "移除重复title标签并添加新标签")
                    elseif title_count == 1 then
                        -- 替换空的title标签
                        chunk = string.gsub(chunk, "<title[^>]*>.-</title>", "<title>" .. ngx.ctx.title .. "</title>", 1)
                        -- ngx.log(ngx.INFO, "替换空的title标签")
                    else
                        -- 添加新的title标签
                        local head_exists = string.find(chunk, "<head>", 1, true)
                        if head_exists then
                            chunk = string.gsub(chunk, "<head>", "<head><title>" .. ngx.ctx.title .. "</title>", 1)
                            -- ngx.log(ngx.INFO, "添加新的title标签")
                        end
                    end
                    ngx.ctx.title_injected = true
                end
            end
            
            -- 去重meta标签
            local seen_meta = {}
            chunk = ngx.re.gsub(chunk, [[<meta[^>]*(name|property)="([^"]+)"[^>]*content="([^"]*)"[^>]*>]], function(m)
                local key = m[1] .. ":" .. m[2]
                if seen_meta[key] then 
                    -- ngx.log(ngx.INFO, "移除重复的meta标签: " .. key)
                    return "" 
                end
                seen_meta[key] = true
                return m[0]
            end, "jo")
            
            ngx.arg[1] = chunk
        }
        
        try_files $uri $uri/ /im/index.html;
    }

    # assets目录 - 直接指向static/assets
    location /assets/ {
        alias /usr/share/nginx/html/poetize/static/assets/;
        expires 30d;
        add_header Cache-Control "public, no-transform";
    }

    # 静态资源 - 同时尝试从poetize目录直接找，或从poetize/static子目录找
    location /static {
        try_files $uri @fallback_static;
        expires 30d;
        add_header Cache-Control "public, no-transform";
    }

    # Live2D模型和相关资源 - 专门优化Live2D资源的缓存
    location /static/live2d_api/ {
        root /usr/share/nginx/html/poetize;
        expires max;  # 使用最长缓存时间，因为模型文件很少变化
        add_header Cache-Control "public, max-age=31536000, immutable";
        
        # 配置跨域
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods 'GET, OPTIONS';
        
        # 特别优化model_list.json的缓存
        location ~ model_list\.json$ {
            expires 1d;  # 模型列表可能会更新，使用较短的缓存时间
            add_header Cache-Control "public, max-age=86400";
        }
        
        # 禁用access_log以减少磁盘IO
        access_log off;
    }
    
    # Live2D小部件JS和CSS资源
    location /static/live2d-widget/ {
        root /usr/share/nginx/html/poetize;
        expires 7d;  # 一周的缓存时间
        add_header Cache-Control "public, max-age=604800";
        
        # 禁用access_log以减少磁盘IO
        access_log off;
    }

    # 静态资源回退路径
    location @fallback_static {
        root /usr/share/nginx/html/poetize;
        expires 30d;
        add_header Cache-Control "public, no-transform";
    }

    # 站点地图和robots.txt文件
    location /sitemap.xml {
        alias /app/data/sitemap.xml;
    }
    
    location /robots.txt {
        alias /app/data/robots.txt;
    }

    # Java后端API
    location /api/ {
        # 增加请求速率限制，防止暴力攻击
        limit_req zone=api_limit burst=20 nodelay;
        
        proxy_pass http://poetize-java:8081/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # Java后端用户相关API - 添加此段，确保与其他配置一致
    location /user/ {
        # 增加更严格的请求速率限制，防止暴力破解登录
        limit_req zone=user_limit burst=5 nodelay;
        
        proxy_pass http://poetize-java:8081/user/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;
        proxy_read_timeout 300s;
        proxy_send_timeout 300s;
    }
    
    location /socket {
        proxy_pass          http://poetize-java:9324;
        proxy_http_version  1.1;
        proxy_set_header    Upgrade $http_upgrade;
        proxy_set_header    Connection "upgrade";
        proxy_read_timeout  600s;
    }

    # Python后端API
    location /python/ {
        # 增加请求速率限制，防止暴力攻击
        limit_req zone=python_limit burst=10 nodelay;
        
        proxy_pass http://poetize-python:5000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # 清理SEO缓存接口
    location = /flush_seo_cache {
        # 只允许内部/本地访问
        allow all;

        content_by_lua_block {
            local seo_cache = ngx.shared.seo_cache
            seo_cache:flush_all()
            ngx.say("seo cache flushed")
        }
    }
}